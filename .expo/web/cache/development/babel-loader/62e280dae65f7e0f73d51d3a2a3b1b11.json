{"ast":null,"code":"var _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar util = require(\"./util\");\nvar CREDENTIAL_FIELD_ID = [0x10, 0x0e];\nvar SSID_FIELD_ID = [0x10, 0x45];\nvar AUTH_TYPE_FIELD_ID = [0x10, 0x03];\nvar NETWORK_KEY_FIELD_ID = [0x10, 0x27];\nvar AUTH_TYPES = {\n  OPEN: [0x00, 0x00],\n  WPA2_PSK: [0x00, 0x20]\n};\nfunction _getLengthBytes(valueBytes) {\n  if (valueBytes.length > 255) {\n    return [Math.floor(valueBytes.length / 256), valueBytes.length % 256];\n  }\n  return [0x0, valueBytes.length];\n}\nfunction _arrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction _getNextTLV(bytes) {\n  var type = bytes.slice(0, 2);\n  var length = bytes.slice(2, 4);\n  var value = bytes.slice(4, 4 + (length[0] * 256 + length[1]));\n  return {\n    type: type,\n    length: length,\n    value: value\n  };\n}\n\nfunction decode(bytes) {\n  var result = {};\n  while (bytes.length > 0) {\n    var _getNextTLV2 = _getNextTLV(bytes),\n      type = _getNextTLV2.type,\n      value = _getNextTLV2.value;\n    bytes = bytes.slice(4 + value.length, bytes.length);\n    if (_arrayEqual(CREDENTIAL_FIELD_ID, type)) {\n      var credential = value;\n      while (credential.length > 0) {\n        var tlv = _getNextTLV(credential);\n        credential = credential.slice(4 + tlv.value.length, credential.length);\n        if (_arrayEqual(AUTH_TYPE_FIELD_ID, tlv.type)) {\n          result.authType = tlv.value;\n        } else if (_arrayEqual(SSID_FIELD_ID, tlv.type)) {\n          result.ssid = util.bytesToString(tlv.value);\n        } else if (_arrayEqual(NETWORK_KEY_FIELD_ID, tlv.type)) {\n          result.networkKey = util.bytesToString(tlv.value);\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfunction encode(_ref) {\n  var ssid = _ref.ssid,\n    networkKey = _ref.networkKey,\n    _ref$authType = _ref.authType,\n    authType = _ref$authType === void 0 ? AUTH_TYPES.WPA2_PSK : _ref$authType;\n  if (typeof ssid !== 'string' || typeof networkKey !== 'string') {\n    throw new Error('');\n  }\n  ssid = util.stringToBytes(ssid);\n  networkKey = util.stringToBytes(networkKey);\n\n  var authTypeTLV = [].concat(AUTH_TYPE_FIELD_ID, [0x0, authType.length], _toConsumableArray(authType));\n  var ssidTLV = [].concat(SSID_FIELD_ID, [0x0, ssid.length], _toConsumableArray(ssid));\n  var networkKeyTLV = [].concat(NETWORK_KEY_FIELD_ID, [0x0, networkKey.length], _toConsumableArray(networkKey));\n\n  var credentialValue = [].concat(_toConsumableArray(authTypeTLV), _toConsumableArray(ssidTLV), _toConsumableArray(networkKeyTLV));\n  var credentialTLV = [].concat(CREDENTIAL_FIELD_ID, _toConsumableArray(_getLengthBytes(credentialValue)), _toConsumableArray(credentialValue));\n  return credentialTLV;\n}\nmodule.exports = {\n  encodePayload: encode,\n  decodePayload: decode,\n  authTypes: AUTH_TYPES\n};","map":{"version":3,"names":["util","require","CREDENTIAL_FIELD_ID","SSID_FIELD_ID","AUTH_TYPE_FIELD_ID","NETWORK_KEY_FIELD_ID","AUTH_TYPES","OPEN","WPA2_PSK","_getLengthBytes","valueBytes","length","Math","floor","_arrayEqual","arr1","arr2","i","_getNextTLV","bytes","type","slice","value","decode","result","credential","tlv","authType","ssid","bytesToString","networkKey","encode","Error","stringToBytes","authTypeTLV","ssidTLV","networkKeyTLV","credentialValue","credentialTLV","module","exports","encodePayload","decodePayload","authTypes"],"sources":["/Users/dp-tonmai/Documents/my-solito-app/node_modules/react-native-nfc-manager/ndef-lib/ndef-wifi-simple.js"],"sourcesContent":["var util = require('./util');\n\nconst CREDENTIAL_FIELD_ID = [0x10, 0x0e];\nconst SSID_FIELD_ID = [0x10, 0x45];\nconst AUTH_TYPE_FIELD_ID = [0x10, 0x03];\nconst NETWORK_KEY_FIELD_ID = [0x10, 0x27];\n\nconst AUTH_TYPES = {\n  OPEN: [0x00, 0x00],\n  WPA2_PSK: [0x00, 0x20],\n};\n\nfunction _getLengthBytes(valueBytes) {\n  if (valueBytes.length > 255) {\n    return [Math.floor(valueBytes.length / 256), valueBytes.length % 256];\n  }\n  return [0x0, valueBytes.length];\n}\n\nfunction _arrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction _getNextTLV(bytes) {\n  const type = bytes.slice(0, 2);\n  const length = bytes.slice(2, 4);\n  const value = bytes.slice(4, 4 + (length[0] * 256 + length[1]));\n  return {\n    type,\n    length,\n    value,\n  };\n}\n\n// @returns an string of wifi credentials\nfunction decode(bytes) {\n  let result = {};\n\n  while (bytes.length > 0) {\n    let {type, value} = _getNextTLV(bytes);\n    bytes = bytes.slice(4 + value.length, bytes.length);\n\n    if (_arrayEqual(CREDENTIAL_FIELD_ID, type)) {\n      let credential = value;\n\n      while (credential.length > 0) {\n        let tlv = _getNextTLV(credential);\n        credential = credential.slice(4 + tlv.value.length, credential.length);\n\n        if (_arrayEqual(AUTH_TYPE_FIELD_ID, tlv.type)) {\n          result.authType = tlv.value;\n        } else if (_arrayEqual(SSID_FIELD_ID, tlv.type)) {\n          result.ssid = util.bytesToString(tlv.value);\n        } else if (_arrayEqual(NETWORK_KEY_FIELD_ID, tlv.type)) {\n          result.networkKey = util.bytesToString(tlv.value);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n// encode wifi object payload\n// @returns an array of bytes\nfunction encode({ssid, networkKey, authType = AUTH_TYPES.WPA2_PSK}) {\n  if (typeof ssid !== 'string' || typeof networkKey !== 'string') {\n    throw new Error('');\n  }\n\n  ssid = util.stringToBytes(ssid);\n  networkKey = util.stringToBytes(networkKey);\n\n  // build seperated TLV\n  const authTypeTLV = [\n    ...AUTH_TYPE_FIELD_ID,\n    0x0,\n    authType.length,\n    ...authType,\n  ];\n  const ssidTLV = [...SSID_FIELD_ID, 0x0, ssid.length, ...ssid];\n  const networkKeyTLV = [\n    ...NETWORK_KEY_FIELD_ID,\n    0x0,\n    networkKey.length,\n    ...networkKey,\n  ];\n\n  // build credential TLV\n  const credentialValue = [...authTypeTLV, ...ssidTLV, ...networkKeyTLV];\n  const credentialTLV = [\n    ...CREDENTIAL_FIELD_ID,\n    ..._getLengthBytes(credentialValue),\n    ...credentialValue,\n  ];\n\n  return credentialTLV;\n}\n\nmodule.exports = {\n  encodePayload: encode,\n  decodePayload: decode,\n  authTypes: AUTH_TYPES,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}